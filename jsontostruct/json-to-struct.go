package jsontostruct

import (
	"encoding/json"
	"fmt"
	"strings"
)

type structInfo struct {
	structName string
	structType string
	depth int
	structFlag int
}

var (
	noFlag = 0
	baseFlag = 1
	objFlag = 2
	arrFlag = 4
)

var (
	baseStructName = "AutoGenerated"
	outputArr = [...]string{"%s\t%s\t`json:%s`", "", "%s struct {", "type %s struct {",
	"%s\t[]%s\t`json:%s`", "", "%s []struct {", "type %s []struct {"}

        outputArgNums = [...]int{3,0,1,1,3,0,1,1}
)

func (si *structInfo) String() string {
	for i := 0; i < si.depth; i++ {
		fmt.Print("\t")
	}
	var args []interface{}
	if outputArgNums[si.structFlag] == 1 {
		args = append(args, si.structName)
	} else if outputArgNums[si.structFlag] == 3 {
		args = append(args, si.structName)
		args = append(args, si.structType)
		args = append(args, si.structName)
	}
	return fmt.Sprintf(outputArr[si.structFlag], args...)
}

func jsonWalk(key string, value interface{}, depth, flag int) {
	var si *structInfo
	switch value.(type) {
	case nil:
		si = &structInfo{key, "interface{}", depth, flag}
	case int:
		si = &structInfo{key, "int", depth, flag}
	case bool:
		si = &structInfo{key, "bool", depth, flag}
	case string:
		si = &structInfo{key, "string", depth, flag}
	case float64:
		si = &structInfo{key, "float64", depth, flag}
	case map[string]interface{}:
		parseJson(key, value, depth, flag|objFlag)
	case []interface{}:
		parseJson(key, value, depth, flag|arrFlag)
	}
	fmt.Println(si)
}

func parseJson(name string, record interface{}, depth, flag int) {
	if recordObj, ok := record.(map[string]interface{}); ok {
		flag |= objFlag
		if depth == 0 {
			flag |= baseFlag
		}
		fmt.Println(&structInfo{name, "", depth, flag})
		depth++
		flag = noFlag
		for k, v := range recordObj {
			jsonWalk(k, v, depth, flag)
		}
		endStructOutput(name, depth)
	} else if recordArr, ok := record.([]interface{}); ok {
		flag |= arrFlag
		if depth == 0 {
			flag |= baseFlag
		}
		jsonWalk(name, recordArr[0], depth, flag)
	}
	return
}

func endStructOutput(structName string, depth int) {
	depth--
	for i := 0; i < depth; i++ {
		fmt.Print("\t")
	}
	fmt.Print("}")
	if depth != 0 {
		fmt.Printf(" `json:%s`\n", structName)
	}
}

func generateStruct(jsonStr string) error {
	dec := json.NewDecoder(strings.NewReader(jsonStr))
	var record interface{}
	if err := dec.Decode(&record); err != nil {
		fmt.Println("err:", err.Error())
		return err
	}
	parseJson(baseStructName, record, 0, 0)
	return nil
}
