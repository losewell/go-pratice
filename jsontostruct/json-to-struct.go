package jsontostruct

import (
	"encoding/json"
	"fmt"
	"strings"
	"log"
)

type structInfo struct {
	structName string
	structType string
	depth int
	structFlag int
}

var (
	noFlag = 0
	baseFlag = 1
	objFlag = 2
	arrFlag = 4
)

var (
	baseStructName = "AutoGenerated"
	outputArr = [...]string{"%s\t%s\t`json:%s`\n", "", "%s struct {\n", "type %s struct {\n",
				"%s\t[]%s\t`json:%s`\n", "", "%s []struct {\n", "type %s []struct {\n"}
)

func (si *structInfo) String() string {
	for i := 0; i < si.depth; i++ {
		fmt.Print("\t")
	}
	return si.structName + "\t" + si.structType + "\t" + fmt.Sprintf(`json:%s`, si.structName)
}

func parseJson(name string, record interface{}, depth, flag int) {
	var si *structInfo
	var realV interface{}
	if flag & arrFlag == 0 {
		si = &structInfo{name, record, depth, flag}
		fmt.Println(si)
		depth++
	}

	for k, v := range record {
		realV = v
		if _, ok := v.([]interface{}); ok {
			flag |= arrFlag
			realV = v[0]
		}
		if flag & arrFlag == 0 {
			flag = noFlag
		}
		switch realV.(type) {
		case nil:
			si = &structInfo{k, "interface{}", depth, flag}
		case int:
			si = &structInfo{k, "int", depth, flag}
		case bool:
			si = &structInfo{k, "bool", depth, flag}
		case string:
			si = &structInfo{k, "string", depth, flag}
		case float64:
			si = &structInfo{k, "float64", depth, flag}
		case map[string]interface{}:
			parseJson(k, v, depth, flag|objFlag)
		}
		fmt.Println(si)
	}
	depth--

	for i := 0; i < depth; i++ {
		fmt.Print("\t")
	}
	fmt.Println("}")
}

func generateStruct(jsonStr string) error {
	dec := json.NewDecoder(strings.NewReader(jsonStr))
		var record interface{}
		if err := dec.Decode(&record); err != nil {
			log.Fatal(err)
		}
		switch record.(type) {
		case map[string]interface{}:
			parseJson(baseStructName, record.(map[string]interface{}), 0, baseFlag|objFlag)
		case []interface{}:
			parseJson(baseStructName, record[0].(map[string]interface{}), 0, baseFlag|arrFlag)
		}
}
